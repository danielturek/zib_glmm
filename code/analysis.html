<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Introduction</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h3>Introduction</h3>

<p>We&#39;ll look at two different ways of parametrizing your model.  The first uses latent states, and is the traditional form for occupancy models (the only to fit these models in most software).  The second parametrization will be NIMBLE-only, and we&#39;ll see is much faster.</p>

<p>I&#39;ve did some processing of your data, to remove the huge numble of NA&#39;s from the raw observation matrix.  Instead of large 2-dimensional arrays, with only roughly about 600 actual observations, the data is now in &#39;flat&#39; structures: 1-dimensional vectors containing <em>only</em> the 600 actual obsevations, with a new site-membership indicator variable <code>siteID</code> for correctly specifying the random effects.</p>

<pre><code class="r">## load the nimble library
library(nimble)

## load the processed data
load(&#39;../data/zib_data.RData&#39;)

## some other function definitions for custom samplers, ploting, etc.
source(&#39;definitions.R&#39;)

## this has to do with how the page is being made
fromR &lt;- TRUE
</code></pre>

<h3>Latent state model</h3>

<p>The latent state version of the model includes the latent &#39;z&#39; variables, indicating actual presence / absense.  Including these introduces about 600 additional latent variables into the model which must be sampled, which slows down the MCMC a lot.</p>

<p>In the second formulation of the model, we&#39;ll use a custom distribution in NIMBLE to remove these latent states.  But to use JAGS (for initial comparison), we can&#39;t use custom distributions, and therefore use the latent state model representation.</p>

<pre><code class="r">code &lt;- nimbleCode({
    mu_alpha ~ dnorm(0, 0.001)
    sigma_alpha ~ dunif(0, 500)
    tau_alpha &lt;- 1 / (sigma_alpha * sigma_alpha)
    for(j in 1:nsite) { 
        alpha[j] ~ dnorm(mu_alpha, tau_alpha)  ## site random effect
    }
    for(i in 1:10) {
        beta[i] ~ dnorm(0, 0.001)
    }
    ## notice the single index i, using the new &#39;flat&#39; data structures
    ## also the siteID group membership, used to assign the correct random effect
    for(i in 1:N) {
        logit(p_occ[i]) &lt;- alpha[siteID[i]] + beta[4]*aet[i] + beta[5]*tmn[i] + beta[6]*tmx[i] + beta[7]*year[i] + beta[8]*month[i] + beta[9]*year2[i] + beta[10]*month2[i]
        logit(p_obs[i]) &lt;- beta[1] + beta[2]*list_length[i] + beta[3]*year_list_length[i]
        z[i] ~ dbern(p_occ[i])
        mu_y[i] &lt;- z[i] * p_obs[i]
        y[i] ~ dbern(mu_y[i])
    }
})

## notice everything is the &#39;flat&#39; structure
constants &lt;- list(N=N, nsite=nsite, aet=aetflat, tmn=tmnflat, tmx=tmxflat, year=yearflat, year2=year2flat, month=monthflat, month2=month2flat, list_length=list_lengthflat, year_list_length=year_list_lengthflat, siteID=siteIDflat)

## notice everything is the &#39;flat&#39; structure
data &lt;- list(y=yflat)

inits &lt;- list(mu_alpha=0, sigma_alpha=1, alpha=rep(0,nsite), beta=rep(0,10), z=rep(1,N))

## LS indicates model information for the &#39;latent state&#39; version
modelInfo_LS &lt;- list(code=code, constants=constants, data=data, inits=inits, name=&#39;LS&#39;)
</code></pre>

<p>We&#39;ll use both NIMBLE and JAGS to fit the latent state model</p>

<pre><code class="r">## specify 22,000 iterations, after 2000 burnin will leave 20,000 samples
niter &lt;- 22000

set.seed(0)

comp_LS &lt;- compareMCMCs(modelInfo_LS,
                        niter = niter,
                        summary = TRUE,
                        MCMCs = c(&#39;jags&#39;,&#39;nimble&#39;))

save(comp_LS, file = &#39;../cached/comp_LS.RData&#39;)
</code></pre>

<p>We&#39;ll take a look at how quickly that ran, and the resulting effective sample size (ESS).  ESS takes into account the autocorrelation in the posterior chains, and is a measure of the actual number of <em>independent</em> posterior samples.</p>

<pre><code class="r">## this gives the runtime (in minutes of each algorithm)
comp_LS$LS$timing / 60
</code></pre>

<pre><code>##           jags         nimble nimble_compile 
##       5.216933       0.389750       0.390900
</code></pre>

<p>JAGS takes about 5 minutes, NIMBLE takes about 30 seconds, to produce 20,000 samples.</p>

<pre><code class="r">## This shows the *minimum efficiency* for all samples parameters, which is the number of effective samples produces per second of runtime.
comp_LS$LS$efficiency$min
</code></pre>

<pre><code>##       jags     nimble 
## 0.01101648 0.14159698
</code></pre>

<p>JAGS produces about 1 sample every 100 seconds, and NIMBLE is about 1 sample every 7 seconds.  Those times are for how long the algorithm must run.</p>

<p>This is too slow.  We&#39;ll stop looking at the latent state model here, and move on to the next, faster, model representation.</p>

<p>system(&#39;~/utils/publish.sh analysis.R&#39;)</p>

<p>make_MCMC_comparison_pages(comp_LS, dir = &#39;../html&#39;)</p>

<pre><code class="r"> dOccupancy model
niter &lt;- 502000
set.seed(0)
comp_dOcc &lt;- compareMCMCs(modelInfo_dOccupancy,
                          MCMCs = c(&#39;nimble&#39;, &#39;block&#39;, &#39;log_shft&#39;, &#39;log_shft_blk&#39;, &#39;log_shft2_blk&#39;),
                          niter = niter,
                          ##summary = TRUE,
                          summary = FALSE,
                          MCMCdefs = list(
                              block = quote({
                                  spec &lt;- configureMCMC(Rmodel)
                                  spec$removeSamplers(&#39;beta[1:10]&#39;)
                                  spec$addSampler(&#39;beta[1:3]&#39;, &#39;RW_block&#39;)
                                  spec$addSampler(&#39;beta[4:10]&#39;, &#39;RW_block&#39;)
                                  spec }),
                              log_shft = quote({
                                  spec &lt;- configureMCMC(Rmodel)
                                  spec$removeSamplers(&#39;sigma_alpha&#39;)
                                  spec$addSampler(&#39;sigma_alpha&#39;, &#39;RW_log_shift&#39;, list(shiftNodes=&#39;alpha&#39;))
                                  spec }),
                              log_shft_blk = quote({
                                  spec &lt;- configureMCMC(Rmodel)
                                  spec$removeSamplers(&#39;beta[1:10]&#39;)
                                  spec$addSampler(&#39;beta[1:3]&#39;, &#39;RW_block&#39;)
                                  spec$addSampler(&#39;beta[4:10]&#39;, &#39;RW_block&#39;)
                                  spec$removeSamplers(&#39;sigma_alpha&#39;)
                                  spec$addSampler(&#39;sigma_alpha&#39;, &#39;RW_log_shift&#39;, list(shiftNodes=&#39;alpha&#39;))
                                  spec }),
                              log_shft2_blk = quote({
                                  spec &lt;- configureMCMC(Rmodel)
                                  spec$removeSamplers(&#39;beta[1:10]&#39;)
                                  spec$addSampler(&#39;beta[1:3]&#39;, &#39;RW_block&#39;)
                                  spec$addSampler(&#39;beta[4:10]&#39;, &#39;RW_block&#39;)
                                  spec$removeSamplers(&#39;sigma_alpha&#39;)
                                  spec$addSampler(&#39;sigma_alpha&#39;, &#39;RW_log_shift&#39;, list(shiftNodes=&#39;alpha&#39;))
                                  spec$removeSamplers(&#39;mu_alpha&#39;)
                                  spec$addSampler(&#39;mu_alpha&#39;, &#39;RW_shift&#39;, list(shiftNodes=&#39;alpha&#39;, skipDependencies=FALSE))
                                  spec })
                          ))


save(comp_dOcc, file = &#39;../cached/comp_dOcc.RData&#39;)


comp_dOcc$dOccupancy$timing
comp_dOcc$dOccupancy$efficiency

make_MCMC_comparison_pages(comp_dOcc, dir = &#39;../html&#39;)
system(&#39;open ../html/dOccupancy.html&#39;)


samples &lt;- comp_dOcc$dOccupancy$samples
dim(samples)

iPlot &lt;- 400000:498000
tsplot(comp_dOcc$dOccupancy$samples[&#39;nimble&#39;,       &#39;sigma_alpha&#39;, iPlot])
tsplot(comp_dOcc$dOccupancy$samples[&#39;block&#39;,        &#39;sigma_alpha&#39;, ])
tsplot(comp_dOcc$dOccupancy$samples[&#39;log&#39;,          &#39;sigma_alpha&#39;, ])
tsplot(comp_dOcc$dOccupancy$samples[&#39;log_shft&#39;,     &#39;sigma_alpha&#39;, ])
tsplot(comp_dOcc$dOccupancy$samples[&#39;log_shft_blk&#39;, &#39;sigma_alpha&#39;, ])

samples &lt;- comp_dOcc$dOccupancy$samples
iPlot &lt;- 400000:500000


MCMCs &lt;- c(&#39;nimble&#39;, &#39;block&#39;, &#39;log_shft&#39;, &#39;log_shft_blk&#39;, &#39;log_shft2_blk&#39;)
nMCMCs &lt;- length(MCMCs)
dev.new(height=8, width=8)
par(mfrow = c(nMCMCs, 1))
for(i in 1:nMCMCs) {
    tsplot(samples[MCMCs[i], &#39;sigma_alpha&#39;, iPlot], main=MCMCs[i])
}
</code></pre>

<p>################################################</p>

<h1>dOccupancy version of zip model</h1>

<p>################################################</p>

<p>code &lt;- nimbleCode({
    mu_alpha ~ dnorm(0, 0.001)
    sigma_alpha ~ dunif(0, 500)
    for(j in 1:nsite) { 
        alpha[j] ~ dnorm(mu_alpha, sd = sigma_alpha)  ## site random effect
    }
    for(i in 1:10) {
        beta[i] ~ dnorm(0, 0.001)
    }
    ##for(i in 1:nlist) {        # i: events (year-months)
    ##    for(j in 1:nsite) {    # j: sites
    for(i in 1:N) {
        logit(p_occ[i]) &lt;- alpha[siteID[i]] + beta[4]*aet[i] + beta[5]*tmn[i] + beta[6]*tmx[i] + beta[7]*year[i] + beta[8]*month[i] + beta[9]*year2[i] + beta[10]*month2[i]
        logit(p_obs[i]) &lt;- beta[1] + beta[2]*list_length[i] + beta[3]*year_list_length[i]
        y[i] ~ dOccupancy(p_occ[i], p_obs[i])
    }
})</p>

<p>constants &lt;- list(N=N, nsite=nsite, aet=aetflat, tmn=tmnflat, tmx=tmxflat, year=yearflat, year2=year2flat, month=monthflat, month2=month2flat, list_length=list_lengthflat, year_list_length=year_list_lengthflat, siteID=siteIDflat)</p>

<p>data &lt;- list(y=yflat)</p>

<p>inits &lt;- list(mu_alpha=0, sigma_alpha=1, alpha=rep(0,nsite), beta=rep(0,10))</p>

<p>modelInfo_dOccupancy &lt;- list(code=code, constants=constants, data=data, inits=inits, name=&#39;dOccupancy&#39;)</p>

<p>rm(list = c(&#39;code&#39;, &#39;constants&#39;, &#39;data&#39;, &#39;inits&#39;))</p>

</body>

</html>
